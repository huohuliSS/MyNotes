[TOC]

# java面试题

![](https://images.gitbook.cn/f3c480e0-3be2-11e9-82f8-0f2e500ca934)

## 一、java基础

### 如何理解Java中的多态

理解：**相同类型的变量调用同一个方法时表现出不同的行为特征**，这就是多态

好处：**消除了类与类之间的耦合性；大大提高了程序的简洁性和可扩展性**

> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性

### 列出常见的几种异常

**RunException**

NullPointerException（空指针异常）

ClassCastException（类型转化异常）

IllegalArgumentException（传递非法参数异常）

IndexOutOfBoundsException（下标越界异常）

SQLException（操作数据库异常）

IOException（输入输出异常）

NoSuchMethodException（方法未找到异常）

OutOfMemoryError（内存溢出）

### short s1 = 1；s1 = s1 + 1；有错吗？那s1 += 1；有错吗

前者不正确，后者正确。对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型， 需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 =  (short)(s1 + 1);其中有隐含的强制类型转换。 

### Integer对象自动装箱问题

当int值 i >= -128 或 i <= 127时，不会new新的Integer对象，直接引用常量池中的Integer对象

当int值 i不在-128~127范围内的时候，就会new一个新的Integer对象

### 什么是Java序列化

序列化就是一种处理对象流的机制，所谓对象流就是将对象的内容进行流化，可以对流化后的对象进行读写操作，也可以进行网络之间的传输

### HashMap、HashTable、HashSet区别

 `HashMap`：

> HashMap底层数组+链表实现，内部维护了一个存储数据的Entry数组，每个Entry是一个单链表，通过单链表解决冲突问题，当单链表的大小超过`8`时，链表则转化为红黑树，进一步增加了查询效率，当小于6时则又恢复链表。
>
> 非线程安全，多线程环境下可采用**concurrentHashMap**
>
> HashMap内部存储的Entry数组默认是16，当size > 16 * 加载因子(默认0.75)时进行扩容，扩容大小要求一定为2的整数次幂，

- **HashMap扩容机制**

```java
static int indexFor(int h, int length) {  
       return h & (length-1);  
   }  
```

> 首先计算`key得到hashcode`值，然后跟`数组的长度 - 1` 做 `“与”` 运算。当数组的长度为2的n次方幂的时候，不同的key算出相同的index几率小，在**数组上分布比较均匀，减少了碰撞的几率，这样hashMap的查询效率比较高**
>
> 当HashMap要进行扩容时，最消耗性能的点就是，需要将元素组的数组重新计算其在新数组的位置并放进去，就是调用resize()方法；

`HashTable`

> HashTable底层是数组+链表同样基于哈希表实现的，内部也是用过单链表解决的hash冲突问题
>
> 是线程安全的，能够用于多线程环境中
>
> HashTable在不指定容器大小的情况下默认容量为11

**HashMap和HashTable区别**

> - 继承父类不同 ： HashTable继承自Dictionary类，HashMap继承自AbstractMap类，但二者都实现了Map接口
>
> - **线程安全不同** ： HashTable中的方法是Synchronize的，线程安全，HashMap线程不安全
>
> - **key和value是否为null** ： HashMap允许key和value为空，hashTable中key和value都不允许为空
>
> - 计算hash值不同 ： hashTable直接使用对象的hashCode；hashMap重新计算了可以的hash值
>
> - 是否提供contains方法 ： HashMap去掉了HashTable中的contains方法，改为containsValue和containsKey，而HashTable中保留了contains，containsValue和containsKey三个方法
>
> - **内部实现使用的数组初始化和扩容方式不同** ：
>
>   ​       HashTable在不指定容器的情况下默认为11，hashMap默认为16，HashTable不要求容量为2的整数次幂，而HashMap则要求一定为2的整数次幂
>
>   ​       HashTable扩容时，将容量变为原来的2倍加1，HashMap扩容时，将容量变为原来的2倍

**HashSet和HashMap区别**

> - HashSet实现了Set接口，集合中不允许有重复的元素；HashMap实现了Map接口
> - HashMap存储**键值对**，HashSet存储的是**对象**
> - HashMap使用键计算hahCode，HashSet使用成员对象来计算hashcode值，对于两个对象来hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false
> - **HashSet底层实际上使用的是HashMap**

### 理解什么是JavaBean

> JavaBean只**是一种规范而不是某种类**，为了实现这个规范，要满足下面4个条件：
>
> 1、所有属性为private
>
> 2、提供默认的构造方法
>
> 3、提供getter和setter方法
>
> 4、实现serializable接口

### URI和URL的区别

> URI统一资源标志符，表示web上每一种可用的资源，如HTML文档，图像、视频、程序等；URL统一资源定位符，是URI的一个子集，不仅唯一标识资源而且还提供了定位该资源的信息。
>
> **URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。**

### JDBC的流程

- 加载JDBC的驱动
- 建立与数据库的连接
- 创建sql命令statement对象
- 执行sql语句并返回结果集
- 关闭连接

### 进程之间的通信方式

进程通信（IPC）有管道、消息队列、信号量、共享存储、Socket和Streams等

**线程的5中状态**

新建  -> 可运行 -> 运行 -> 阻塞 -> 死亡

### 反射中Class.forName和ClassLoader区别

Class.forName类加载时会对**static代码块初始化**，而ClassLoader不会初始化

### Java中的4中引用

- 强引用（通过new创建的对象，有引用变量指向时，永远不会被垃圾回收，直至抛异常）
- 软引用（内存空间足够，不会被回收，内存空间不足，就会回收）
- 弱引用（用来描述非必须对象，当jvm进行垃圾回收时，不管内存是否足够，都会被回收）
- 虚引用（如果一个对象与虚引用关联，则跟没有引用与之关联一样，任何时候都会被回收）

### 拦截器、过滤器、监听器（三大器）的区别

**拦截器**：动态拦截action调用的对象，它提供了一种机制可以使开发者在一个action执行前后执行一段代码，也可以在一个action执行前阻止其执行，例如Spring的AOP的实现

> 适用场景：审计日志
>
> 注：拦截器只能拦截部分web请求，是基于**java反射机制（动态代理）**实现的

**过滤器**：基于函数回调对web请求进行筛选、过滤

> 适用场景：设置字符编码、URL级别的权限访问控制、过滤敏感词汇

**监听器**：Servlet监听器用于监听一些重要事件的发生，监听器对象可以在事情发生前、发生后可以做一些必要的处理。

> 适用场景：统计在线人数、清楚过期session

**拦截器和过滤器的区别**

（过滤器可以简单的理解为“取你想取”，过滤器关注的是web请求；拦截器可以简单的理解为“拒你想拒”，拦截器关注的是方法调用，比如拦截）

- 拦截器是基于java反射机制实现的，而过滤器是基于函数回调实现的
- 拦截器不依赖servlet容器，过滤器依赖serlvet容器

## 二、多线程(JUC)

### Runnable和Callable接口的区别

- Callable规定的方法为call()，而Runnable规定的方法是run()；
- Callable可以有返回值，Runnable没有返回值
- call()方法可以抛异常，而run()不能抛出异常

### Lock和synchronize的区别

synchronized 的缺陷

> - 程序执行完同步代码块会释放代码块
> - 程序在执行同步代码块时出现异常，JVM会自动释放锁去处理异常

​        如果获取锁的线程需要等待I/O或者调用了sleep()方法被阻塞了，但仍持有锁，其他线程只能干巴巴的等着，这样就会很影响程序效率。
​        因此就需要一种机制，可以不让等待的线程已知等待下去，比如值等待一段时间或响应中断，Lock锁就可以办到。

当多个线程进行读写文件时，读操作和写操作发生冲突，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。通过Lock可以实现。

**区别：**

> - Lock是一个接口，而synchronize是关键字
> - **synchronize会自动释放锁（异常），而Lock必须手动释放锁**
> - Lock可以让**等待锁的线程响应中断**，而synchronize不会，线程会一直等待下去
> - 通过Lock**可以知道线程有没有拿到锁**，而synchronize不能
> - synchronize能锁住类、方法和代码块，而Lock是块范围内的

### volicate与synchronize区别

> - volicate是线程同步的轻量级实现，volicate只能修改变量，而synchronize可以修饰方法，以及代码块
> - 多线程访问volicate不会发生阻塞，而synchronize会出现阻塞
> - **volicate能保证数据之间的可见性，不能保证原子性；而synchronize可以保证原子性和可见性**
> - **volicate解决的是变量在多线程之间的可见性；而synchronize解决的是多线程之间资源同步问题**

### 为什么ConcurrentHashMap是线程安全的

jdk1.7中，Concurrenthashmap使用**分段锁**技术，将数据分成一段一段的存储，然后对每一段数据配一把锁（segment），segment继承了reentrantLock，具备锁和释放锁的功能，Concurrenthashmap只有16个Segment，并且不会扩容，最多支持16个线程并发。

jdk1.8放弃使用分段锁，采用**CAS+Synchronized**方式处理并发，以put操作为例，CAS方式确定key的数组下标，synchronized保证链表节点的同步效果。这样做的方式好处是：减少内存的开销；随JVM的synchronized性能提高而提高。

### Synchronized和ReentrantLock区别

- Sync是java 的关键字，ReentrantLock是一个类实现的是Lock接口欧
- Sync是通过JVM加锁解锁，ReentrantLock是api层面加锁，需要手动释放锁
- Sync不可中断，除非抛出异常，ReentrantLock可设置线程等待时间
- ReentranLock提供更丰富的功能，比如公平锁和非公平锁
- ReentrantLock具有更好的**细粒度**，可以在ReentrantLock里面设置内部Condititon类，可以**实现分组唤醒需要唤醒的线程**

### 线程局部变量ThreadLocal

ThreadLocal类是一种**以空间换时间**的做法，在每个Thread里面维护了一个ThreadLocalMap，为每一个线程的提供一个独立的变量副本，将数据进行隔离，而不会影响到其他线程对应的副本。

### 什么是CAS

CAS原子操作是compare and swap的缩写，即比较交换。cas是一种基于**乐观锁**的操作，cas操作包含三个操作数——**内存位置**（V）、**预期原值**（A）和**新值**（B）。如果内存地址里的值和A的值是一样的，那么就将内存里的值更新为B。CAS是通过线循环来获取数据的，如果内存地址的值被修改了则需要进行**自旋**。

CAS容易造成ABA问题，通过添加**版本号**解决

### 什么是AQS

全名：AbstractQueuedSynchronizer，是并发容器juc下的一个类，实现了FIFO的队列，底层实现的数据结构是一个双向链表。（详细见百度）

### 什么是Java内存模型

java内存模型的特点：**可见性**、**原子性**、**有序性**

JVM运行程序的实体是线程，每个线程创建时JVM都会创建一个工作内存空间（栈空间），工作内存是每个线程的私有数据区域，主内存是共享内存区域，所有线程都可以访问。线程对变量的操作必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存。

### Java中有什么锁？

公平锁/非公平锁、可重入锁、独享锁/共享锁、互斥锁/读写锁、乐观锁/悲观锁、分段锁、偏向锁、轻量级锁

## 三、java虚拟机（JVM）

详细请见JUC与JVM

## 四、计算机网络

### TCP和UDP的区别

> **TCP** ：是**面向连接**的流传输控制协议，具有**高可靠性**，确保传输数据的正确性，有**验证重发机制**，因此不会出现丢失或乱序。
>
> **UDP** ：是**无连接的数据报服务**，不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序，但具有较好的实时性，UDP段结构比TCP的段结构简单，因此网络开销也小

### TCP三次握手和四次挥手全过程

TCP报文格式中还有：Sequence number(序号)、Acknowledge number(确认序号)、标志位

其中标志位，有六种：SYN(建立联机)、ACK(确认)、PSH(传送)、FIN(结束)、PST(重置)、URG(紧急)

**三次握手**

![](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> - 第一次握手：客户端发送一个请求报文发送给服务器，报文首部中的同步标志位SYN=1,ACK=0, 同时选择一个初始序列号 seq = x，此时客户端进入SYN_SEND状态，等待服务器确认；
> - 第二次握手：服务器收请求报文后，如果同意连接，则发出确认报文，确认报文中的ACK=1，SYN=1，确认序号为x+1，同时也要为自己初始化一个序列号seq = y，发送给客户端，此时服务器进入SYN_RECV状态；
> - 第三次握手：客户端收到服务器发送的数据包，还要想服务器发出确认，发送确认报文，确认报文的ACK=1，确认序号为 y+1，自己的序列号为 x+1，此时包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包中不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦确立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。

**四次挥手**

![](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> - 第一次挥手：主动关闭方，发送一个FIN = 1,seq = u（结束标志），用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发送数据了，但是，**此时主动关闭方还可以接受数据**。
> - 第二次挥手：**被动关闭方接收到FIN包后，其实不会直接发送FIN标志断开通信的请求，而是先发送一个带有ACK标志的应答信息，使主动关闭方明白还有数据要进行发送**。发送一个ACK = 1,seq = v给对方，确认序号ack 为u + 1，（与syn相同，一个FIN占用一个序号）
> - 第三次挥手：被动关闭方发送一个FIN  = 1（结束标志）,ACK = 1,seq = w,确认序号ack=u+1数据包，告诉主动关闭方，我的数据也发送完了，不会再给你发数据了,通知对方断开连接。
> - 第四次挥手：主动关闭方收到数据包后，担心网络上某些不可控制的因素导致服务器不知道它要断开连接，会发送一个ACK=1给被动关闭方，序号为u+1，确认序号为w+1，同时把自己设置成TIME_WAIT状态并启动定时器，在TCP的定时器到达客户端并没有接收到请求，会重新发送；当对方收到请求后就断开连接，完成四次握手。

### TCP建立连接为什么是三次握手而不是两次

**原因**：为了防止失效的连接请求报文段被服务端接收。从而产生错误。

> 若建立连接只需要两次握手，客户端

### 为什么四次挥手

> **确保数据能够完成传输**，但关闭连接时，当收到对方的 FIN 报文通知时，它 仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文 给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的

### 谈谈http

http协议由http请求和http响应组成

> HTTP请求包括：请求行、请求头、请求体
>
> HTTP响应包括：响应行、响应头、响应体

特点：

- 基于请求/响应模式的协议
- 默认端口为80
- 简单快速，请求的方式有GET、POST、PUT等等
- 灵活：允许传输任意类型的数据对象，添加Content-Type响应头标记
- 无连接的：每次只处理一个请求，服务器处理完请求客户的请求后，及断开连接，可节省传输时间
- 无状态：是指协议对事物处理没有记忆能力，后续的连接需要用到之前的信息，则必须要重传。为了解决这一特性，出现了Cookie和Session

### 什么是同步IO、异步IO

- 同步IO：当用户发出IO请求操作之后，如果数据没有准备就绪，需要通过**用户线程**或**系统内核**不断去**轮询**数据是否就绪；当数据就绪时，再将数据从内核拷贝到用户线程。
- 异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成的，然后告诉用户线程IO操作已完成，在异步IO中，不会对用户线程产生任何阻塞。

### 说说NIO

NIO有三大核心组成部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器），传统IO是基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据从通道读取到缓冲区，或缓冲区写入到通道中。Selector用于监听多个通道的事件。因此**单个线程可以监听多个数据通道**。

NIO的操作办法是：**将socket交给操作系统内核处理，内核会自动感知有数据的socket**（在linux下，叫fd文件描述符）

**select、poll、epoll的区别**

> select -> 时间复杂度O(n)： 当有I/O事件发生时，却不知道是哪个流，我们只能**无差别轮询**所有流，找出能读出数据，对它们进行操作。select缺点：**单个进程可监视的fd数量被限制**；**对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低**
>
> poll -> 时间复杂度O(n)：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间中，然后查询每个fd对应的设备信息，但是**它没有最大连接数的限制**，原因是它基于链表来存储的。
>
> epoll -> 时间复杂度O(1)：epoll会把那个流发生了怎样的I/O事件通知我们
>
> **epoll的优点**：
>
> - **没有最大连接数的限制**，能打开的fd（文件描述符）上限远远大于1024
> - 效率提升，**不采用轮询的方式**，不会随着fd的数目增加而效率下降，活跃可用的fd系统内核会自动将数据拷贝到用户线程

### NIO和BIO

BIO是同步阻塞IO，服务器实现模型为一个**连接**一个线程，内核再检查数据未就绪时，就会一直等待，直到数据就绪

NIO为同步非阻塞IO，服务器实现模型为一个**请求**一个线程，客户端发送的连接请求都会注册到多路复用器上

### DNS解析过程

服务器的包含关系：**根DNS服务器  > 顶级DNS服务器 > 权威DNS服务器 > 二级域名的DNS服务器**

> ​		1.先向本地dns缓存查看有没有该域名对应的ip地址，有直接跳出，没有接着往下
>
> 　　2.向根dns服务器询问域名对应的ip地址(根dns服务器会让他去查询顶级dns服务器)
>
> 　　3.向顶级dns服务器询问域名对应的ip地址(顶级dns服务器会让他去查询权威dns服务器)
>
> 　　4.向权威dns服务器询问域名对应的ip地址(权威dns服务器会让他去查询二级dns服务器)
>
> 　　5.向二级dns服务器询问域名对应的ip地址(二级dns服务器会返回对应的ip地址)
>
> 　　6.接收到ip地址后，会先把ip和域名对应关系保存到本地dns缓存，以便下次方便访问

## 五、数据库

### 什么是索引

索引看做是目录，其实是为了使查询数据效率更快，快速找出某个列中有一特定值的行。

### 数据库三大范式

- 字段不可分（原子性）
- 有主键，非主键字段依赖主键（要求数据库表中的每个实例或行必须可以被惟一地区分）
- 非主键字段不能相互依赖（要求一个数据库表中不包含已在其它表中已包含的非主键字段）

### 数据库四大特性

- 原子性

  > 事务包含的所有操作要么全部成功，要么全部失败

- 一致性

  > 事务执行前和执行后必须处于一致性的状态（前后总和不变）

- 隔离性

  > 多个事务之间的操作互不影响，相互隔离

- 持久性

  > 一个事物一旦被提交，对数据库中的数据的改变就是永久性的

### 数据库四种隔离级别

数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable。而在事务的并发操作中可能会出现**脏读**、**不可重复读**、**幻读**。

- 读未提交

  > 一个事务处理过程里读取到了另一个未提交的事务中的数据，也称之为**脏读**

- 读已提交

  > 一个事务要等另一个事务提交后才能读取到数据。若有事务对数据进行操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，**解决了脏读**的问题。

- 可重复读

  > 就是在开始读取数据（事务开启）时，不在允许修改操作
  >
  > 可重复读**解决了不可重复读问题**。

- 序列化

  >  这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，**从而解决幻读问题**。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
  >

### MyISAM和InnoDB区别

- MyISAM：默认**表**类型，它是基于传统的ISAM类型，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。

  > MyISAM使用的是非聚集索引，索引文件个数据文件存储在不同的文件中

- InnoDB：支持事务安全的引擎，支持**外键、行锁、事务**是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。

  > InnoDB使用的是聚集索引，将主键组织到一棵B+树中，而行数据全部存储在叶子节点上

### 聚集索引和非聚集索引的区别

- 聚集索引：

  表示**表中存储的数据按照索引的顺序存储**，索引和数据全部存在同一个文件中，检索效率比非聚集索引高，但对数据更新影响大

- 非聚集索引：

  非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。

### Mysql主从复制

- **为什么需要主从复制**

  > 提升性能：当主数据库发生故障时，可以切换到从数据库继续工作，防止数据的丢失。
  >
  > 降低压力：可以让主数据库负责写，从数据库负责读，读写分离

- **主从复制的原理**

  > （1）master服务器将数据的改变记录在二进制文件中，当master上的数据反生改变时，将其改变的sql语句写入到（binlog）二进制文件中
  >
  > （2）salve服务器会在一定的时间对master二进制进行探测其是否发生改变，如果发生改变，则开启一个**I/O线程**请求master二进制事件
  >
  > （3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的relay-log（**中继日志**）文件中，从节点会启动**sql线程**从中继日志中读取二进制日志，再次执行sql语句，保持与主节点一致。

### Mysql性能优化

####  一、数据库设计方面

- 选择正确的数据库引擎

Mysql中主要有两个引擎MyISAM和InnoDB，每个引擎都有利弊

> MyISAM适用于一些大量查询的应用，但对大量写功能的应用不是很好。甚至你只需要一个update字段整个表就会被锁起来，而别的进程就算是读操作也不行，要等到当前的update操作完成后才能继续进行
>
> InnoDB的趋势会是一个非常复杂的存储引擎，对于一些小的应用会比MyISAM慢，但是默认支持的是**行锁**，所以在写操作比较多的时候会比较优秀，并且，它支持很多的高级应用，例如：**事务**。

- 对查询进行优化，应避免全表扫描，首先考虑在where和order by涉及的列加上索引

- 应尽量避免在where子句中对字段进行null判断，否则将会导致引擎放弃使用索引而进行全表扫描

- 尽量使用数字型字段，若只含数字信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并增加存储开销，字符串索引在处理时，引擎会逐个比较字符串中的每一个字符，而对于数字型索引而言只需要必须要比较一次就行

- 尽量使用varchar代替char，因为首先可变字长存储字段空间小，可以节省存储空间

#### 二、SQL语句方面

> - **应尽量避免在where子句中使用 != 和 <>操作符，否则引擎将放弃使用索引而进行全表扫描**
>
> - **应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，(可用 union all 联合查询代替)**
>
> - **in 和 not  in也要慎用，否则也会进行全表扫描，对于数值能用between 就不要用 in 了**
>
> - **应尽量避免在where子句中对字段进行函数、算术运算或其他表达式操作，这将导致引擎放弃使用索引而进行全表扫描**
>
> - **当只要一行数据时使用 `limit 1**`
>
>   查询时如果已知会得到一条数据，这种情况下加上 `limit 1`会增加性能。因为mysql数据库索引擎会找到一条结果后就停止搜索，而不是继续查询下一条是否符合标准直到所有记录查询完毕。
>
> - **使用not exists 代替 not in**
>
>   Not exists 用到了连接能够发挥已经建立号的索引的作用，**not in不能使用索引**，Not in是最慢的方式要同每条记录比较，在数据量比较大的操作不建议使用这种方式。
>
> - **sql语句需要什么字段就返回什么字段，用具体的字段代替 `***`

#### 三、主从复制

## 六、框架

### SpringMVC的执行流程

> - 用户向服务器发送请求，请求被SpringMVC的前端控制器DispatchServlet捕获
> - DispatchServlet对请求的URL进行解析，发送给处理器映射器HandlerMapping
> - 处理器映射器找到具体的处理器，生成器拦截器(如果有则生成)一并返回给DispatchServlet
> - DispatchServlet调用HandlerAdapter处理器适配器
> - HandlerAdapter经过适配器调用具体的处理器(Controller)
> - 处理器返回一个modelAndView给HandlerAdapter
> - HandlerAdapter返回DispatchServlet。
> - DispatchServlet请求视图解析器(ViewReslover)，进行渲染视图
> - ViewReslover解析后返回具体的View视图给DispatchServlet，最后响应用户

### 谈谈对Spring的理解

> Spring 是一个开源框架，为简化企业级应用而开发。**Spring是一个IOC和AOP的容器框架**
>
> Spring容器核心主要有三个：IOC、DI、AOP
>
> - IOC控制反转，Spring使用了**工厂模式+反射+配置文件**为我们创建了所需要的对象，不需要我们手动创建，将创建对象的权利交给Spring管理，其中BeanFactory接口是容器核心。
> - DI依赖注入，Spring使用javaBean对象的**set方法**或者**带参数的构造方法**为我们在创建时将所其属性自动设置所需要的值的过程
> - AOP面向切面，（切面=切点(增强内容)+通知(方法)）在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个**切面**，对这个切面进行一些如**权限控制、事物管理，记录日志**等 公用操作处理的过程。AOP底层实现的**动态代理**，接口采用的是jdk动态代理，类采用CGLIB方式实现动态代理。（优点：减少了代码之间的耦合度，对原有代码没有侵入性）

补充： Java 动态代理是**利用反射机制生成一个实现代理接口的匿名类**，在调用具体方法前调用 InvokeHandler 来处理。 

而 cglib 动态代理是利用 asm 开源包，对**代理对象类的 class 文件加载进来**，**通过修改其字节码生成子类**来处理。

### cglib动态代理的本质

字节码织入

拼装字节码数组  ->  根据JVM指令码编译成class文件（ASM）  -> 实例生成对象

dubbo的实现和mybatis的懒加载

### Mybatis

Mybatis是一个半ORM（对象关系映射）框架，内部封装了JDBC，开发只需关注sql语句就可以了

**优点**：简化jdbc的开发、简单灵活、解除sql与程序代码的耦合、支持xml标签和动态sql

**执行流程**：1、加载核心配置文件；2、获取sqlSessionFactory对象；3、获取sqlSession会话；

​					4、调用执行器执行sql请求；5、生成MapperStatement对象与数据库交互（Mybatis在启动的时候，会解析这些包含sql的xml文件，并将其包装成MapperStatement对象）

### 什么是ORM？

就是对象关系数据库和实体类之间做一个映射，作用是用面向对象的方式去操作数据库的创建表以及增删改查等操作。

### Mybatis的Mapper接口的工作原理

Mapper接口的工作原理是**JDK动态代理**，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会**拦截接口方法**，转而执行MapperStatement所代表的的sql，然后执行sql结果返回。

### Mybatis和hiberate有哪些不同

- Mybatis和hiberate不同，他不完全是一个ORM框架
- Mybatis直接编写sql语句，灵活性好
- Hiberate对象/关系映射能力强，数据库无关性好，所以可移植性强

### BeanFactory和FactoryBean的区别

BeanFactory是个bean工厂，负责生产和管理bean的一个工厂，也是spring IOC荣放弃的最底层的接口，是spring用来管理和装配bean的ioc容器。

FactoryBean是个bean，是spring提供的工厂bean的一个接口，在IOC容器的基础上给bean的实现加上了一个简单工厂模式和装饰模式。

### BeanFactory和ApplicationContext的区别

主要体现在装载Bean的区别

> **BeanFactory**是**基础类型的IOC容器，提供完成的IOC服务的支持**，如果没有特殊指定，默认采用延迟初始化策略（**懒加载**）
>
> **ApplicationContext**是在BeanFactory的基础上构建的，是相对于比较高级的容器实现，除了 BeanFactory 的所有 支持外，ApplicationContext 还提供了更多的功能。
>
> - ApplicationContext 管理的对象，在容器启动后默认全部初始化并且绑定完成
>
> - 国际化
> - 访问资源，如URL和文件（）

### redis

- String字符串类型

  > 应用场景：缓存结构体信息（例如：保存json字符串、计数功能）

- List列表类型（数据结构类似于java的LinkedList，内部双向链表）

  > List类型的前后插入和删除速度是非常快的
  >
  > 使用场景：**List可用于秒杀抢购场景**
  >
  > ​		  秒杀可以使用redis的list数据类型来实现，在秒杀前将本秒杀的商品放到list中，因为list的**pop操作是有原子性的**，所以即使有多个用户同时请求，也是依次pop，list空了pop抛出异常就代表商品卖完了。

- Hash数据类型（数据结构类似于HashMap，内部也是数组+链表，hash类型必须为字符串）

- Set集合类型（相当于HashSet，无序且无重复的）

- ZSet有序集合

  > 和Set一样也是String类型元素的集合，且不允许重复，不同的是Zset每个元素都会关联一个double类型的分数（scope），通过scope来为集合中的成员进行从小到大的排序

### redis主从复制的原理

> 1、从服务器连接主服务器，发送SYNC命令
>
> 2、主服务器接收到SYNC命令，开始执行将数据保存到一个文件中执行所有写命令，保存完后向所有从服务器发送快照（RDB）文件
>
> 3、从服务器接收到快照文件后，载入接收到的快照

### Redis的持久化RDB和AOF

**RDB**（快照）

> 能够在指定的时间间隔内能对你数据进行**快照**存储。redis会**单独创建（fork）一个子进程**来进行持久化，会先将数据写入到一个临时文件中（dump.rdb），待持久化过程结束了，再用这个临时文件替换上次持久化好的文件，主进程不进行任何IO操作
>
> **优点：**适合大规模数据的数据恢复；**对数据完整性的要求不高**
>
> **缺点：**最后一次持久化后的数据可能会丢失；fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。

**AOF**

> 以**日志**（默认appendonly.aof二进制文件）的形式来记录每个**写操作**，将redis执行过的所有写指令记录下来（**读记录不记录**），只许追加文件但不可以改写文件。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作
>
> **aof重写(rewrite)**：AOF采用文件追加方式，文件会越来越大为了避免出现这种情况，当AOF文件的大小超过所设定的大小时，redis会将AOF文件进行内容压缩。默认配置是当AOF文件大小是上次rewrite大小的一倍且文件大小为64M
>
> 优点：三种appendfsync方式：always、everysec、no
>
> 缺点：相同数据集的数据而言aof文件要远大于rdb文件，回复速度慢；

### Nginx

什么是nginx？

> nginx是一个高性能的http和反向代理服务器



## 七、Improve

### 为什么使用非关系型数据库

- 数据库表结构

  > 关系型数据库需要提前定义表结构，并定义好每个列所占的存储空间即类型，这样就带来一个问题，受限于表本身的结构。
  >
  > 非关系型数据库可以随意添加字段和值，不受表本身的结构，所以很方便，表数据没有冗余。随着大数据的发展，各式各样结构的数据有很多，符合大数据的一些特点

- 读写速度

  > 关系型数据库在数据量小的时候是很有优势的，但是在集群这种大数据的背景下就会有大量的数据缓存，这样就导致插入修改会非常慢

- 集群的扩展

  > 关系型数据库扩展性是非常麻烦的，而且添加机器的时候要进行rebalance，耗时；但是现在的非关系型数据库基本上都是基于内存而设计的，类型存储不需要固定的模式，无需多余的操作就可以横向扩展，性能效率较高。

### 什么是CAP（分布式）

- C：Consistency 一致性：数据在多个副本之间是否能够保持一致的特性。（当一个系统在一致状态下更新后，应保持系统中所有数据仍处于一致的状态）

- A：Availability 可用性：系统提供的服务必须一直处于可用状态，对每一个操作的请求必须在有限时间内返回结果。

- P：Tolerance of network Partition 分区容错性：分布式系统在遇到网络分区故障时，仍然需要保证对外提供一致性和可用性的服务，除非整个网络都发生故障。



redis锁 五种类型的结构

如何防止高并发

currentHashMap和HashMap

NIO和BIO的区别

如何解决秒杀问题

shiro运行原理

springmvc原理及文件下载

quartz任务调度

synchorinzed底层实现

reentrantLock与synchronize区别

桶排序

